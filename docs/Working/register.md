After a successful authentication, the client hits the `/device` endpoint which creates a new entry in the devices table.

| Field | Value |
|-------|-------|
| ID | 52f4e559-1152-4506-ae0f-122a9a08296b |
| Machine Name | Jobins-MacBook-Pro.local |
| Platform | Java 21.0.3 |
| Device ID | e224b21e-d5d7-4eab-b7ab-c54c1bfd2460 |
| IP Address | - |
| User ID | 778d1900-8634-4ec6-9805-52f91338acea |

### Device ID
The device ID is a unique identifier for the device. It is generated by the client and is used to identify the device in the database to prevent duplicate entries and multiple IP addresses being assigned to the same device.

The device ID generation is done on the client side, but it's not flawless; it's just a best-effort scenario.

For example, in the desktop client, it's just a random UUID that is generated and saved in preferences.

```kotlin
actual fun uniqueDeviceId(): String {
    val settings by inject<Settings>(Settings::class.java)
    val deviceId = settings.get("device_id", "")
    if (deviceId.isEmpty()) {
        val uuid = UUID.randomUUID().toString()
        settings.putString("device_id", uuid)
        return uuid
    }
    return deviceId
}
```

In Android: [^1]
```kotlin
actual fun uniqueDeviceId(): String {
    val context by inject<Context>(Context::class.java)
    return AndroidSettings.Secure.getString(context.contentResolver, AndroidSettings.Secure.ANDROID_ID)
}
```
[^1]: 
    Android doesn't recommend using hardware identifiers for unique identification, so based on their [recommendation](http://developer.android.com/identity/user-data-ids) the current implementation might be changed in the future.

And in iOS:

```kotlin
actual fun uniqueDeviceId(): String {
    return UIDevice().identifierForVendor?.UUIDString!!
}
``` 

### IP Address

IP address is empty when the device is registered for the first time. When the device proceeds to sign the public key, the IP address is updated in the database. More about it in the next step.